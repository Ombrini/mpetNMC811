"""Helper functions/classes for outputting data generated by the simulation."""
import numpy as np
import os
import sys
import time
import h5py

import daetools.pyDAE as dae
from daetools.pyDAE.data_reporters import daeMatlabMATFileDataReporter


class MyMATDataReporter(daeMatlabMATFileDataReporter):
    """See source code for pyDataReporting.daeMatlabMATFileDataReporter"""
    def WriteDataToFile(self):
        mdict = {}
        #0 if single simulaiton, 1 if continued simulation
        continued_sim = 0
        #if we are in a directory that has continued simulations (maccor reader)
        if os.path.isfile(self.ConnectionString + ".hdf5"):
            if os.stat(self.ConnectionString + ".hdf5").st_size != 0:
                continued_sim = 1
                #remains 0 if not continued sim
        with h5py.File(self.ConnectionString + ".hdf5", 'a') as mat_dat:
            for var in self.Process.Variables:
                # Remove the model name part of the output key for
                # brevity.
                dkeybase = var.Name[var.Name.index(".")+1:]
                # Remove dots from variable keys. This enables the mat
                # file to be read by, e.g., MATLAB.
                dkeybase = dkeybase.replace(".", "_")
                mdict[dkeybase] = var.Values
                #if we are not in a continuation directory
                if dkeybase == 'phi_applied' and continued_sim == 0:
                    #only save times for voltage
                    mdict['times'] = var.TimeValues
                    mat_dat.create_dataset('phi_applied_times', data = mdict['times'], maxshape = (None,))

                #if we are in a directory that has continued simulations (maccor reader)
                if continued_sim == 1:
                    #increment time by the previous end time of the last simulation
                    tend = mat_dat['phi_applied_times'][-1]
                    #get previous values from old output_mat
                    mdict[dkeybase] = mdict[dkeybase] 

                    #resize and append dkeybase variable 
                    mat_dat[dkeybase].resize((mat_dat[dkeybase].shape[0] + mdict[dkeybase].shape[0]), axis = 0)
                    mat_dat[dkeybase][-mdict[dkeybase].shape[0]:] = mdict[dkeybase]

                    if dkeybase == 'phi_applied':
                        mdict['times'] = var.TimeValues + tend
                        #resize and append dkeybase varibale
                        mat_dat['phi_applied_times'].resize((mat_dat['phi_applied_times'].shape[0] + mdict['times'].shape[0]), axis = 0)             
                        mat_dat['phi_applied_times'][-mdict['times'].shape[0]:] = mdict['times']

                else:
                    #create dataset if continued_sim == 0
                    #maxshape is set dpeending on whether its a 2D array or a 1D array
                    shape = len(mdict[dkeybase].shape)
                    mat_dat.create_dataset(dkeybase, data = mdict[dkeybase], maxshape = (None,)*shape)


def setup_data_reporters(simulation, outdir):
    """Create daeDelegateDataReporter and add data reporter."""
    datareporter = dae.daeDelegateDataReporter()
    simulation.dr = MyMATDataReporter()
    datareporter.AddDataReporter(simulation.dr)
    # Connect data reporters
    simName = simulation.m.Name + time.strftime(" [%d.%m.%Y %H:%M:%S]",
                                                time.localtime())
    #we name it another name so it doesn't overwrite our output data file
    matDataName = "output_data"
    matfilename = os.path.join(outdir, matDataName)
    if not simulation.dr.Connect(matfilename, simName):
        sys.exit()
    # a hack to make compatible with pre/post r526 daetools
    try:
        simulation.dr.ConnectionString = simulation.dr.ConnectString
    except AttributeError:
        pass
    return datareporter
